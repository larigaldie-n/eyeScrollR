[{"path":[]},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/eyeScrollR.html","id":"understand-the-use-case-scenario","dir":"Articles","previous_headings":"Before you start","what":"Understand the use-case scenario","title":"Introduction to eyeScrollR","text":"Consider situation, participant fixates 6 different areas screen (represented red green spots) browsing website, scrolls , fixates 6 exact areas:  Although red fixation spots indeed match content situations, green fixations spots don’t; analysis content fixated convert screen coordinates “content coordinates”. words, unrolled content screen single long image, like fixations correctly placed , :  … exactly package . top , may often want get rid anything outside website (browser header, Windows bar bottom, etc.), areas websites might static follow screen even participant scrolls . eyeScrollR equipped deal situations.","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/eyeScrollR.html","id":"set-up-the-experimental-setting","dir":"Articles","previous_headings":"Before you start","what":"Set up the experimental setting","title":"Introduction to eyeScrollR","text":"Although eyeScrollR deals participants’ data, getting reliable accurate placements timings requires changing browser settings. omitted, steps often result pixels inaccuracy fixation’s coordinates, may temporarily ahead time ~150ms scrolling blur periods. Quite rarely, may mess whole file; especially participant fast-paced erratic scrolling pattern. user deactivate smooth scrolling browser used study, get rid side scrollbar. Chrome/Chromium browsers, deactivating smooth scrolling can easily done typing “chrome://flags/” address bar disabling “Smooth Scrolling” option. Similarly, scrollbar can hidden enabling “Overlay Scrollbars” option. Firefox browsers, free extensions can easily found hide scrollbar, smooth scrolling can deactivated directly settings menu.","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/eyeScrollR.html","id":"anticipate-the-necessary-information-material","dir":"Articles","previous_headings":"Before you start","what":"Anticipate the necessary information & material","title":"Introduction to eyeScrollR","text":"eyeScrollR mainly designed work full page images websites. can automatically captured various free paid extensions Chromium/Firefox browsers (probably ), manually constructed/modified necessary. resulting image full page image, horizontal size equal browser viewing area vertical size equal total length webpage. Procuring image left reader’s preferences. image, need measurements monitor used experiment, eye-tracking dataset including participant’s mouse inputs fixation coordinates, set. measurements can done automatically Calibration page, can also input manually necessary.","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/eyeScrollR.html","id":"a-complete-example","dir":"Articles","previous_headings":"","what":"A complete example","title":"Introduction to eyeScrollR","text":"desire, able follow along (webpage used example can found ). Arguably, first step even getting eye-tracker data get measurements ready calibration phase.","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/eyeScrollR.html","id":"calibrate","dir":"Articles","previous_headings":"A complete example","what":"Calibrate","title":"Introduction to eyeScrollR","text":"purpose calibration feed program size screen, location browsing area inside screen, many pixels scrolled time participant scrolls browser used. just go Calibration page follow instructions. scroll_pixels value, take screenshot whole screen, including calibration page, save image file. several monitors computer, make sure take screenshot monitor eye-tracker used. Therefore, resulting image exactly size monitor resolution.","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/eyeScrollR.html","id":"automatic-calibration","dir":"Articles","previous_headings":"A complete example > Calibrate","what":"Automatic calibration","title":"Introduction to eyeScrollR","text":"fastest easiest way calibrate. Just pass screenshot just took along scroll_pixels value scroll_calibration_auto function. instance: calibration now !","code":"library(eyeScrollR) library(png) library(tidyverse) calibration_image <- readPNG(\"calibrate.png\") calibration <- scroll_calibration_auto(calibration_image = calibration_image,                                        scroll_pixels = 100)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/eyeScrollR.html","id":"manual-calibration","dir":"Articles","previous_headings":"A complete example > Calibrate","what":"Manual calibration","title":"Introduction to eyeScrollR","text":"nearly situations, manual calibration needed. automatic calibration fail suit needs, can always manually. Just open screenshot took earlier look coordinates pixels top left bottom right browsing area. search made easier colored squares corners. graphics editors allow easily get image size coordinates pixel interested just zooming placing cursor (example , pixel interested colored black).  Repeat process bottom rightmost pixel. just report values scroll_calibration_manual function:","code":"calibration <- scroll_calibration_manual(screen_width = 1920, screen_height = 1080,                                          top_left_x = 0, top_left_y = 89,                                          bottom_right_x = 1919, bottom_right_y = 1029,                                          scroll_pixels = 100)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/eyeScrollR.html","id":"get-some-data-and-the-website-image","dir":"Articles","previous_headings":"A complete example","what":"Get some data, and the website image","title":"Introduction to eyeScrollR","text":"next step get full page image website. mentioned earlier, several ways achieve many browser extensions available. case, ended simple image:  image width height passed eye_scroll_correct function next section.","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/eyeScrollR.html","id":"convert","dir":"Articles","previous_headings":"A complete example","what":"Convert","title":"Introduction to eyeScrollR","text":"careful examination video participant’s session key events, determined example participant looking webpage interest timestamps 3577 30864. need now import dataset, includes fixation coordinates, mouse events, timestamps. , can apply correction! optional argument consider scroll_lag argument. Right now, scroll message read immediately implemented eyeScrollR visible monitor participants, take account type input lag. scroll_lab argument set minimum value half display frame duration, around 8.333 60Hz monitors. conservative value, general, argument set follow equation (8.333ms, use \\(n=1\\) 60Hz monitor): \\[ scroll\\_lag = \\frac{1}{2}\\cdot\\frac{1000}{refresh\\_rate}+(n-1)\\cdot\\frac{1000}{refresh\\_rate} \\] can read argument related publication.","code":"test_data <- read_csv(\"test_data.csv\") corrected_data <- eye_scroll_correct(eyes_data = test_data,                                      timestamp_start = 3577,                                      timestamp_stop = 30864,                                      image_width = 1920,                                      image_height = 1442,                                      calibration = calibration)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/eyeScrollR.html","id":"important-considerations-about-the-dataset","dir":"Articles","previous_headings":"","what":"Introduction to eyeScrollR","title":"Introduction to eyeScrollR","text":"dataset follow number rules, especially column naming conventions specific form key events. example assumes user already correctly-formed dataset, may necessary slight changes dataset beforehand. particular, requires columns named Timestamp, Data, least one Gaze.X & Gaze.Y Fixation.X & Fixation.Y pairs columns. pretty self-explanatory except “Data” Column, can contain anything, MUST include participant’s inputs. may specifically (re-)constructed , respect following specific structure mouse scroll happens: X:{mouse X-coordinate}; Y:{mouse Y-coordinate}; MouseEvent:WM_MOUSEWHEEL; ScrollDelta:{integer value: negative scroll , positive scroll } instance, correctly formed event Data column, indicates mouse wheel scrolled pointing coordinates X=150; Y=300: X:150; Y:300; MouseEvent:WM_MOUSEWHEEL; ScrollDelta:-120 specific value ScrollDelta inconsequential just positive negative number. Please refer eye_scroll_correct help page related publication details.","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/eyeScrollR.html","id":"output","dir":"Articles","previous_headings":"A complete example","what":"Output!","title":"Introduction to eyeScrollR","text":"Finally can use built-heatmap generation function data set included fixation data: Putting together code snippets, entire script (including scroll_lag argument) looks like :","code":"heatmap_image <- readPNG(\"a_random_website.png\") generate_heatmap(data = corrected_data, heatmap_image = heatmap_image) library(eyeScrollR) library(png) library(tidyverse) calibration_image <- readPNG(\"calibrate.png\") calibration <- scroll_calibration_auto(calibration_image = calibration_image,                                        scroll_pixels = 100) test_data <- read_csv(\"test_data.csv\") corrected_data <- eye_scroll_correct(eyes_data = test_data,                                      timestamp_start = 3577,                                      timestamp_stop = 30864,                                      image_width = 1920,                                      image_height = 1442,                                      calibration = calibration,                                      scroll_lag = (1/120)*1000) heatmap_image <- readPNG(\"a_random_website.png\") generate_heatmap(data = corrected_data, heatmap_image = heatmap_image)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/eyeScrollR.html","id":"a-more-complicated-setting","dir":"Articles","previous_headings":"","what":"A more complicated setting?","title":"Introduction to eyeScrollR","text":"example kept simple purpose, fixed area inside webpage. complicated example using fixed areas also changing size scroll, can visit article fixed areas","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/fixed_areas.html","id":"the-fixed_areas-list","dir":"Articles","previous_headings":"","what":"The fixed_areas list","title":"Using eyeScrollR with fixed areas","text":"Nowadays, many websites areas move rest scrolled areas. Typically navigation menus top /right, footers. problem even page scrolled bottom, gazing top menu means , full webpage image, gaze suddenly moved bottom page top without scrolling back. instance, consider website (can find ):  moment, let us just ignore fact top area ends shrinking point; come back later. areas top right fixed, scroll bit, content actually moving screen. full webpage image may look like (although result may slightly differ depending plugin using extract image):  really want instruct program matter far scrolled, areas screen always mapped area webpage image (rest may move around). example, show slightly scrolling (gazing content) make program apply scroll correction coordinates scrollable content (green dot), redirecting fixed areas fixed areas across webpage image (red, blue, yellow dots). , fixation top right image scrolls result exact heatmap top left image, scroll made.  way achieve eyeScrollR , rectangles image suggested, map fixed relationship areas screen areas image. Gaze fixation coordinates red rectangle screen always redirected red rectangle image, blue area screen blue rectangle image, yellow area yellow rectangle image. similar way manual calibration procedure, just open screenshot screen browsing website, get coordinates top left bottom right pixels fixed area want map full page image. done, can destination coordinates full page image, following: Left: screenshot image; Right: full webpage image Repeat process every fixed area may encounter. left now actually pass coordinates form package can recognize. order , just need create pairs coordinate vectors pass fixed_areas_bundle function vectors form c(top_left_x, top_left_y, bottom_right_x, bottom_right_y). example, measured following values: imperative pass arguments ordered pairs screen--image mappings, put result list (come reason next section). rectangle pairs must also exact dimensions order maintain 1:1 mapping process. feels like long piece code write: keep reading, much simplified way come code explained later tutorial. explanations make sure understand mapping process works. done, provided already calibration procedure, simply pass fixed_areas argument eye_scroll_correct function: enough simple situations fixed areas never change.","code":"# These two are the top header top_fixed_area_screen <- c(0, 89, 1919, 276) top_fixed_area_image <- c(0, 0, 1919, 187) # These two are the yellowish area on the right right_fixed_area_screen <- c(1632, 277, 1919, 936) right_fixed_area_image <- c(1632, 188, 1919, 847) # These two are the bottom right area bottom_right_fixed_area_screen <- c(1632, 937, 1919, 1029) bottom_right_fixed_area_image <- c(1632, 4284, 1919, 4376)  area_bundle <- fixed_areas_bundle(top_fixed_area_screen,                                   top_fixed_area_image,                                   right_fixed_area_screen,                                   right_fixed_area_image,                                   bottom_right_fixed_area_screen,                                   bottom_right_fixed_area_image)  fixed_areas <- list(area_bundle) corrected_data <- eye_scroll_correct(eyes_data = test_data,                                      timestamp_start = 3577,                                      timestamp_stop = 30864,                                      image_width = 1920,                                      image_height = 4377,                                      calibration = calibration,                                      fixed_areas = fixed_areas)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/fixed_areas.html","id":"the-rules-list","dir":"Articles","previous_headings":"","what":"The rules list","title":"Using eyeScrollR with fixed areas","text":"complicated use-case scenario eyeScrollR can handle fixed areas somewhat dynamic behavior. common example top menu bar shrinks (even disappears!) certain number pixels scrolled . situations, screen--image direct mapping still meaningful across different possible states webpage, possible create several bundles fixed areas mappings create rules instruct package bundle used time. instance, create bundle mappings used user scrolled yet another one used . example provide situation screen--image mapping still meaningful. Indeed, although top area shrinks, remains can still perfectly mapped full page image, whole area shrunken header still perfect correspondence (bottom right area): Top: shrinking; Bottom: shrinking right area critical-case scenario researcher make decision may solve things creatively. Indeed, size area header shrunk now larger one got captured full page image. Therefore, can longer make perfect mapping two areas. cases, might mean impossible map everything single image, might consider splitting participant’s data several images. However, particular case, can choose ignore , even manual editing full page image expand area! Indeed, empty area one interested otherwise never reachable observer: always something right page, long band white artifact screenshot plugin. , possible just make following mapping:  situation, bottom-right coordinates fixed area full page image can calculated making sure two areas (one screen one image) exact size. case, ended following measures: time, fixed_areas list comprises two bundles mappings: one used user scrolled enough shrink top header, one used . thing left create rules list, package can know use bundle. rule function checks, line .csv file, conditions use specific bundle met . case , need first rule asking user scrolled sufficient amount pixels shrink header, case first bundle fixed areas used, otherwise. also require second rule, asking exact opposite second bundle. Finding conditions change fixed areas may require experimentation field. website example, header just retracts 1000 pixels scrolled , expands case. eye_scroll_correct function calls rule functions every line .csv file pass several arguments work . Working complex sets rules possible programming knowledge . case, require write functions. scenario presented easy enough modified whatever level expertise R appropriate vast majority use-case scenarios. order rules must order fixed areas bundles. case, rule_scrolled_up rule therefore make sure first bundle fixed areas used less 1000 pixels scrolled longer used case. Similarly, rule_scrolled_down rule associated second bundle fixed areas. can copy paste functions simply change number 1000 fit needs similar case. feels bit overwhelming, don’t worry: ’ve got covered. Instead writing everything hand, can just use bundle creator gadget running following code: gadget simplifies process letting focus instead . can add/remove fixed areas bundles simple click, fill fixed areas coordinates, select (common) rule need bundle:  output code can copy & paste, thing left modify rules suit needs. Just don’t forget click “done” finished! can just pass list fixed areas list rules eye_scroll_correct function:","code":"# These two are the top header top_fixed_area_bis_screen <- c(0, 89, 1919, 182) top_fixed_area_bis_image <- c(0, 0, 1919, 93) # These two are the yellowish area on the right right_fixed_area_bis_screen <- c(1632, 183, 1919, 936) right_fixed_area_bis_image <- c(1632, 188, 1919, 941) # These two are the bottom right area bottom_right_fixed_area_bis_screen <- c(1632, 937, 1919, 1029) bottom_right_fixed_area_bis_image <- c(1632, 4284, 1919, 4376)  area_bundle_bis <- fixed_areas_bundle(top_fixed_area_bis_screen,                                   top_fixed_area_bis_image,                                   right_fixed_area_bis_screen,                                   right_fixed_area_bis_image,                                   bottom_right_fixed_area_bis_screen,                                   bottom_right_fixed_area_bis_image)  fixed_areas <- list(area_bundle, area_bundle_bis) rule_scrolled_up <- function (data_line, array_fixed_areas, flag, scroll) {     if (scroll <= 1000)     {         return (TRUE)     }     else     {         return (FALSE)     } }  rule_scrolled_down <- function (data_line, array_fixed_areas, flag, scroll) {     if (scroll > 1000)     {         return (TRUE)     }     else     {         return (FALSE)     } }  rules <- list(rule_scrolled_up, rule_scrolled_down) bundles_gadget() corrected_data <- eye_scroll_correct(eyes_data = test_data,                                      timestamp_start = 3577,                                      timestamp_stop = 30864,                                      image_width = 1920,                                      image_height = 4377,                                      calibration = calibration,                                      fixed_areas = fixed_areas,                                      rules = rules,                                      scroll_lag = (1/120)*1000)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/fixed_areas.html","id":"a-complete-commented-code-for-our-example","dir":"Articles","previous_headings":"","what":"A complete, commented code for our example","title":"Using eyeScrollR with fixed areas","text":"","code":"library(eyeScrollR) library(png) library(tidyverse)  ################################################################################ # General settings # Same for every data file for a given webpage # (Do this once per webpage) ################################################################################  ### Automatic calibration calibration_image <- readPNG(\"calibration_chrome.png\") calibration <- scroll_calibration_auto(calibration_image, 125)  ### Fixed area bundles ## First bundle: when not scrolled down yet # These two are the top header top_fixed_area_screen <- c(0, 89, 1919, 276) top_fixed_area_image <- c(0, 0, 1919, 187) # These two are the yellowish area on the right right_fixed_area_screen <- c(1632, 277, 1919, 936) right_fixed_area_image <- c(1632, 188, 1919, 847) # These two are the bottom right area bottom_right_fixed_area_screen <- c(1632, 937, 1919, 1029) bottom_right_fixed_area_image <- c(1632, 4284, 1919, 4376)  area_bundle <- fixed_areas_bundle(top_fixed_area_screen,                                   top_fixed_area_image,                                   right_fixed_area_screen,                                   right_fixed_area_image,                                   bottom_right_fixed_area_screen,                                   bottom_right_fixed_area_image)  ## Second bundle: when scrolled down enough # These two are the top header top_fixed_area_bis_screen <- c(0, 89, 1919, 182) top_fixed_area_bis_image <- c(0, 0, 1919, 93) # These two are the yellowish area on the right right_fixed_area_bis_screen <- c(1632, 183, 1919, 936) right_fixed_area_bis_image <- c(1632, 188, 1919, 941) # These two are the bottom right area bottom_right_fixed_area_bis_screen <- c(1632, 937, 1919, 1029) bottom_right_fixed_area_bis_image <- c(1632, 4284, 1919, 4376)  area_bundle_bis <- fixed_areas_bundle(top_fixed_area_bis_screen,                                       top_fixed_area_bis_image,                                       right_fixed_area_bis_screen,                                       right_fixed_area_bis_image,                                       bottom_right_fixed_area_bis_screen,                                       bottom_right_fixed_area_bis_image)  ### Now, the rule functions # The first one, when we are below 1000 pixels scrolled rule_scrolled_up <- function (data_line, array_fixed_areas, flag, scroll) {   if (scroll <= 1000)   {     return (TRUE)   }   else   {     return (FALSE)   } }  # The second one, when we are above 1000 pixels scrolled rule_scrolled_down <- function (data_line, array_fixed_areas, flag, scroll) {   if (scroll > 1000)   {     return (TRUE)   }   else   {     return (FALSE)   } }  # Create the fixed_areas list with both bundles, and associate rules by putting # them in the same order fixed_areas <- list(area_bundle, area_bundle_bis) rules <- list(rule_scrolled_up, rule_scrolled_down)  ################################################################################ # Participant-specific code ################################################################################ # Read data, and make sure labels are alright test_data <- read_csv(\"fixed_areas.csv\")  # Apply the scroll corrections corrected_data <- eye_scroll_correct(eyes_data = test_data,                                      timestamp_start = 8504,                                      timestamp_stop = 70478,                                      image_width = 1920,                                      image_height = 4377,                                      calibration = calibration,                                      fixed_areas = fixed_areas,                                      rules = rules,                                      scroll_lag = (1/120)*1000)  # Read the full page image heatmap_image <- readPNG(\"fixed_website.png\")  # Output the heatmap generate_heatmap(data = corrected_data, heatmap_image = heatmap_image)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/articles/limitations.html","id":"keypresses-and-scrollbars","dir":"Articles","previous_headings":"","what":"Keypresses and scrollbars","title":"Limitations","text":"eyeScrollR mainly works catching MOUSEWHEEL key events correcting gaze fixation coordinates accordingly. However, mouse wheel way scroll /website, researcher ALWAYS make sure participants , instance, press space bar page key (outside input field). events handled package moment therefore considered . Similarly, participants also discouraged using side scrollbar (completely disabled) reason. Finally, websites scrollbars inside subcomponents. situation, using mouse wheel pointing area scroll subcomponent, whole page. However, eyeScrollR still interpret event scroll entire page. , however, choices either refrain using package settings manually remove scrolling events .csv file. Please note eyeScrollR still new. Although every effort put make sure bug-free, recommended users check final data sets correspond expectations publishing data.","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nathanael Larigaldie. Author, maintainer.","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Larigaldie N, Dreneva , Orquin JL (2023). eyeScrollR: Open-Source User-Friendly R package Gaze-Map Eye Tracking Data Scrollable Webpages. Aarhus University, Aarhus, Denmark. https://github.com/larigaldie-n/eyeScrollR.","code":"@Manual{,   title = {eyeScrollR: An Open-Source and User-Friendly R package to Gaze-Map Eye Tracking Data on Scrollable Webpages},   author = {Nathanael Larigaldie and Anna Dreneva and Jacob L. Orquin},   year = {2023},   organization = {Aarhus University},   address = {Aarhus, Denmark},   url = {https://github.com/larigaldie-n/eyeScrollR}, }"},{"path":"https://larigaldie-n.github.io/eyeScrollR/index.html","id":"eyescrollr","dir":"","previous_headings":"","what":"Correctly place eye-tracking fixation data on areas of scrollable websites","title":"Correctly place eye-tracking fixation data on areas of scrollable websites","text":"R package correctly place eye-tracking gaze & fixation data scrollable web pages","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://larigaldie-n.github.io/eyeScrollR/index.html","id":"installing-eyescrollr","dir":"","previous_headings":"","what":"Installing eyeScrollR","title":"Correctly place eye-tracking fixation data on areas of scrollable websites","text":"","code":"install.packages(\"devtools\") library(devtools) install_github(\"larigaldie-n/eyeScrollR\")"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/bundles_gadget.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a fixed areas bundle gadget — bundles_gadget","title":"Run a fixed areas bundle gadget — bundles_gadget","text":"Automatically generates code fixed areas bundle rules","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/bundles_gadget.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a fixed areas bundle gadget — bundles_gadget","text":"","code":"bundles_gadget()"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/eye_scroll_correct.html","id":null,"dir":"Reference","previous_headings":"","what":"Corrects eye-tracking coordinate data — eye_scroll_correct","title":"Corrects eye-tracking coordinate data — eye_scroll_correct","text":"core function corrects eye-tracking coordinate data fit webpage scrolled vertically participant","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/eye_scroll_correct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Corrects eye-tracking coordinate data — eye_scroll_correct","text":"","code":"eye_scroll_correct(   eyes_data,   timestamp_start,   timestamp_stop,   image_width,   image_height,   calibration,   time_shift = 0,   starting_scroll = 0,   output_file = \"\",   fixed_areas = list(),   rules = list(),   scroll_lag = 0,   outside_image_is_na = TRUE,   progression_bar = TRUE )"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/eye_scroll_correct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Corrects eye-tracking coordinate data — eye_scroll_correct","text":"eyes_data dataset. Please note MUST include correctly named columns (see ) timestamp_start starting timestamp dataset participant watching webpage (INCLUDING time_shift, applicable) timestamp_stop final timestamp dataset participant watching webpage (INCLUDING time_shift, applicable) image_width total width webpage image (pixels) image_height total height webpage image (pixels) calibration calibration list (see scroll_calibration_auto scroll_calibration_manual functions) time_shift [Optional] time shift parameter synchronize dataset another source (e.g. screen recording started timestamp 0 .csv). Default: 0 starting_scroll [Optional] participant start watching webpage top, can indicate y coordinate started (pixels). Default: 0 output_file [Optional] name output .csv file. empty string, just return data without creating file. Default: empty string fixed_areas [Optional] list potentially immovable areas inside webpage (e.g. fixed menus website) - see Fixed Areas article information. Default: empty list rules [Optional] list functions can act rules activate/deactivate immovables areas webpage (e.g. menu disappears X pixels scrolled) - See Fixed Areas article information. Default: empty list scroll_lag [Optional] Determines lag (milliseconds) scroll message scroll correction, account input lag. See related publication information. Default: 0 outside_image_is_na [Optional] Indicates values outside AOI (e.g. windows bar) set NA kept file/dataset. set FALSE, coordinates /AOI become negative. Default: TRUE progression_bar [Optional] Indicates function display progression bar. Default: TRUE","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/eye_scroll_correct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Corrects eye-tracking coordinate data — eye_scroll_correct","text":"Returns dataset added columns corrected coordinates (\"Corrected.Gaze.X\", \"Corrected.Gaze.Y\", \"Corrected.Fixation.X\" \"Corrected.Fixation.Y\"), shifted timestamps (\"Timestamp.Shifted\"), amount pixels scrolled (\"Scroll\")","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/eye_scroll_correct.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Corrects eye-tracking coordinate data — eye_scroll_correct","text":"Dataset  dataset must include correctly named columns, : \"Data\" column, user-generated events (keystrokes browser changes) \"Timestamp\" column timestamps fixation point event \"Gaze.X\" column x coordinate gaze \"Gaze.Y\" column y coordinate gaze \"Fixation.X\" column x coordinate fixation points \"Fixation.Y\" column y coordinate fixation points Data Timestamp columns mandatory, may choose include Gaze data Fixation data ()","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/eye_scroll_correct.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Corrects eye-tracking coordinate data — eye_scroll_correct","text":"","code":"if (FALSE) { library(eyeScrollR) calibration <- scroll_calibration_auto(calibration_image = calibration_image,                                        scroll_pixels = 100) data <- eye_scroll_correct(eyes_data = dataset, timestamp_start = 2000,                                     timstamp_stop = 50000, image_width = 1920,                                     image_height = 10000, calibration = calibration) generate_heatmap(data = data, heatmap_image = heatmap_image) }"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/fixed_areas_bundle.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a bundle of fixed areas mappings — fixed_areas_bundle","title":"Creates a bundle of fixed areas mappings — fixed_areas_bundle","text":"Puts together several fixed areas mappings make (de)activated rule","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/fixed_areas_bundle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a bundle of fixed areas mappings — fixed_areas_bundle","text":"","code":"fixed_areas_bundle(...)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/fixed_areas_bundle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a bundle of fixed areas mappings — fixed_areas_bundle","text":"... varying number pairs coordinate vectors. first pairs always represent area screen, second one area unscrolled image. vector take form c(top_left_x, top_left_y, bottom_right_x, bottom_right_y)","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/fixed_areas_bundle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a bundle of fixed areas mappings — fixed_areas_bundle","text":"bundle fixed areas mappings, put list","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/fixed_areas_bundle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a bundle of fixed areas mappings — fixed_areas_bundle","text":"","code":"if (FALSE) { top_fixed_area_screen <- c(0, 89, 1919, 276) top_fixed_area_image <- c(0, 0, 1919, 187) right_fixed_area_screen <- c(1632, 277, 1919, 936) right_fixed_area_image <- c(1632, 188, 1919, 847) area_bundle <- fixed_areas_bundle(top_fixed_area_screen,                                   top_fixed_area_image,                                   right_fixed_area_screen,                                   right_fixed_area_image) fixed_areas <- list(area_bundle) }"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/generate_heatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates generic heatmap — generate_heatmap","title":"Creates generic heatmap — generate_heatmap","text":"Creates heatmap based dataset full page image","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/generate_heatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates generic heatmap — generate_heatmap","text":"","code":"generate_heatmap(data, heatmap_image)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/generate_heatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates generic heatmap — generate_heatmap","text":"data dataset output eye_scroll_correct function heatmap_image unscrolled webpage image apply heatmap","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/generate_heatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates generic heatmap — generate_heatmap","text":"plot image heatmap","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/generate_heatmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates generic heatmap — generate_heatmap","text":"","code":"if (FALSE) { img <- readPNG(\"test.png\") test_data <- eye_scroll_correct(fixed_areas = test_fixed_areas,     rules = test_rules, calibration = test_calibration) generate_heatmap(data = test_data, heatmap_image = img) }"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_after_scrolling.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic rule to activate a bundle after a certain amount of scrolled\npixels — rule_after_scrolling","title":"Generic rule to activate a bundle after a certain amount of scrolled\npixels — rule_after_scrolling","text":"Helper function enforce fixed area rules (one checks     total amount pixels scrolled top     website superior 30). NB: probably     call function , can use basis     create rule. arguments automatically passed     rule function eye_scroll_correct","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_after_scrolling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic rule to activate a bundle after a certain amount of scrolled\npixels — rule_after_scrolling","text":"","code":"rule_after_scrolling(data_line, fixed_areas_bundle, flag, scroll)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_after_scrolling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic rule to activate a bundle after a certain amount of scrolled\npixels — rule_after_scrolling","text":"data_line current line .csv file. Includes original columns, along new \"Timestamp.Shifted\" column (Timestamp - time_shit), along \"Corrected.X\" \"Corrected.Y\" columns, \"Fixation.X\" \"Fixation.Y\" respectively shifted top_left_x top_left_y calibration stage fixed_areas_bundle array fixed areas linked rule flag boolean says rule TRUE FALSE moment scroll total amount pixels scrolled top website moment","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_after_scrolling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic rule to activate a bundle after a certain amount of scrolled\npixels — rule_after_scrolling","text":"boolean saying rule now enforced ","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_after_scrolling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generic rule to activate a bundle after a certain amount of scrolled\npixels — rule_after_scrolling","text":"","code":"rule_after_scrolling <- function (data_line, fixed_areas_bundle, flag, scroll) {   if (scroll >= 30)   {     return (TRUE)   }   else   {     return(FALSE)   } } rules <- list(rule_before_scrolling, rule_after_scrolling, rule_true)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_before_scrolling.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic rule to activate a bundle before a certain amount of scrolled\npixels — rule_before_scrolling","title":"Generic rule to activate a bundle before a certain amount of scrolled\npixels — rule_before_scrolling","text":"Helper function enforce fixed area rules (one checks     total amount pixels scrolled top     website inferior 30). NB: probably     call function , can use basis     create rule. arguments automatically passed     rule function eye_scroll_correct","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_before_scrolling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic rule to activate a bundle before a certain amount of scrolled\npixels — rule_before_scrolling","text":"","code":"rule_before_scrolling(data_line, fixed_areas_bundle, flag, scroll)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_before_scrolling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic rule to activate a bundle before a certain amount of scrolled\npixels — rule_before_scrolling","text":"data_line current line .csv file. Includes original columns, along new \"Timestamp.Shifted\" column (Timestamp - time_shit), along \"Corrected.X\" \"Corrected.Y\" columns, \"Fixation.X\" \"Fixation.Y\" respectively shifted top_left_x top_left_y calibration stage fixed_areas_bundle array fixed areas linked rule flag boolean says rule TRUE FALSE moment scroll total amount pixels scrolled top website moment","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_before_scrolling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic rule to activate a bundle before a certain amount of scrolled\npixels — rule_before_scrolling","text":"boolean saying rule now enforced ","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_before_scrolling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generic rule to activate a bundle before a certain amount of scrolled\npixels — rule_before_scrolling","text":"","code":"rule_before_scrolling <- function (data_line, fixed_areas_bundle, flag, scroll) {   if (scroll < 30)   {     return (TRUE)   }   else   {     return(FALSE)   } } rules <- list(rule_before_scrolling, rule_after_scrolling, rule_true)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_true.html","id":null,"dir":"Reference","previous_headings":"","what":"A rule that is always true — rule_true","title":"A rule that is always true — rule_true","text":"Helper function enforce fixed area rules (one always     true, meaning rule always enforced). rule     default one fixed area bundle rule attached .     arguments automatically passed rule function     eye_scroll_correct","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_true.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A rule that is always true — rule_true","text":"","code":"rule_true(data_line, fixed_areas_bundle, flag, scroll)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_true.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A rule that is always true — rule_true","text":"data_line current line .csv file. Includes original columns, along new \"Timestamp.Shifted\" column (Timestamp - time_shit), along \"Corrected.X\" \"Corrected.Y\" columns, \"Fixation.X\" \"Fixation.Y\" respectively shifted top_left_x top_left_y calibration stage fixed_areas_bundle bundle fixed areas linked rule flag boolean says rule TRUE FALSE moment scroll total amount pixels scrolled top website moment","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_true.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A rule that is always true — rule_true","text":"boolean saying rule now enforced ","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/rule_true.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A rule that is always true — rule_true","text":"","code":"rule_true <- function (data_line, fixed_areas_bundle, flag, scroll) {   return (TRUE) } rules <- list(rule_before_scrolling, rule_after_scrolling, rule_true)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/scroll_calibration_auto.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatic calibration — scroll_calibration_auto","title":"Automatic calibration — scroll_calibration_auto","text":"Creates calibration list use eye_scroll_correct     function. Uses screenshot full screen including calibration webpage","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/scroll_calibration_auto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatic calibration — scroll_calibration_auto","text":"","code":"scroll_calibration_auto(calibration_image, scroll_pixels)"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/scroll_calibration_auto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatic calibration — scroll_calibration_auto","text":"calibration_image screenshot, loaded large array (e.g. using readPNG) scroll_pixels amount pixels scrolled mouse scroll (depends browser). Output calibration webpage","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/scroll_calibration_auto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatic calibration — scroll_calibration_auto","text":"list representing calibration screen & browser used experiment","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/scroll_calibration_auto.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatic calibration — scroll_calibration_auto","text":"","code":"if (FALSE) { library(png) img <- readPNG(\"calibrate.png\") calibration <- scroll_calibration_auto(calibration_image = img, scroll_pixels = 100) }"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/scroll_calibration_manual.html","id":null,"dir":"Reference","previous_headings":"","what":"Manual calibration — scroll_calibration_manual","title":"Manual calibration — scroll_calibration_manual","text":"Creates calibration list use eye_scroll_correct     function. Uses values taken hand","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/scroll_calibration_manual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manual calibration — scroll_calibration_manual","text":"","code":"scroll_calibration_manual(   screen_width,   screen_height,   top_left_x,   top_left_y,   bottom_right_x,   bottom_right_y,   scroll_pixels )"},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/scroll_calibration_manual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manual calibration — scroll_calibration_manual","text":"screen_width Resolution width screen experiment conducted (pixels). E.g. 1920 screen_height Resolution height screen experiment conducted (pixels). E.g. 1080 top_left_x x coordinate top left pixel browser viewing area top_left_y y coordinate pixel bottom_right_x x coordinate bottom right pixel browser viewing area bottom_right_y y coordinate pixel scroll_pixels amount pixels scrolled mouse scroll (depends browser). Output calibration webpage","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/scroll_calibration_manual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Manual calibration — scroll_calibration_manual","text":"list representing calibration screen & browser used experiment","code":""},{"path":"https://larigaldie-n.github.io/eyeScrollR/reference/scroll_calibration_manual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manual calibration — scroll_calibration_manual","text":"","code":"calibration <- scroll_calibration_manual(1920, 1080, 88, 0, 40, 0, 100)"}]
